// Generated by CoffeeScript 1.10.0
(function() {
  var WiFiScanner, execSyncToBuffer, fs, os_instructions, private_context, win32WirelessProfileBuilder;

  WiFiScanner = require('node-wifiscanner2');

  fs = require('fs');

  execSyncToBuffer = require('sync-exec');

  win32WirelessProfileBuilder = function(ssid, security, key) {
    var profile_content;
    if (security == null) {
      security = false;
    }
    if (key == null) {
      key = null;
    }
    profile_content = "<?xml version=\"1.0\"?> <WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\"> <name>" + ssid.plaintext + "</name> <SSIDConfig> <SSID> <hex>" + ssid.hex + "</hex> <name>" + ssid.plaintext + "</name> </SSID> </SSIDConfig>";
    switch (security) {
      case "wpa":
        profile_content += "<connectionType>ESS</connectionType> <connectionMode>auto</connectionMode> <autoSwitch>true</autoSwitch> <MSM> <security> <authEncryption> <authentication>WPAPSK</authentication> <encryption>TKIP</encryption> <useOneX>false</useOneX> </authEncryption> <sharedKey> <keyType>passPhrase</keyType> <protected>false</protected> <keyMaterial>" + key + "</keyMaterial> </sharedKey> </security> </MSM>";
        break;
      case "wpa2":
        profile_content += "<connectionType>ESS</connectionType> <connectionMode>auto</connectionMode> <autoSwitch>true</autoSwitch> <MSM> <security> <authEncryption> <authentication>WPA2PSK</authentication> <encryption>AES</encryption> <useOneX>false</useOneX> </authEncryption> <sharedKey> <keyType>passPhrase</keyType> <protected>false</protected> <keyMaterial>" + key + "</keyMaterial> </sharedKey> </security> </MSM>";
        break;
      default:
        profile_content += "<connectionType>ESS</connectionType> <connectionMode>manual</connectionMode> <MSM> <security> <authEncryption> <authentication>open</authentication> <encryption>none</encryption> <useOneX>false</useOneX> </authEncryption> </security> </MSM>";
    }
    profile_content += "</WLANProfile>";
    return profile_content;
  };

  switch (process.platform) {
    case "linux":
      os_instructions = require('./linux.js');
      break;
    case "win32":
      os_instructions = require('./win32.js');
      break;
    case "darwin":
      os_instructions = require('./darwin.js');
      break;
    default:
      WiFiLog("Unrecognized operating system.", true);
      process.exit();
  }

  private_context = {
    WiFiControlSettings: {
      iface: null,
      debug: false
    },
    execSync: function(command, options) {
      var results;
      if (options == null) {
        options = {};
      }
      results = execSyncToBuffer(command, options);
      if (!results.status) {
        return results.stdout;
      }
      throw {
        stderr: results.stderr
      };
    },
    WiFiLog: function(msg, error) {
      if (error == null) {
        error = false;
      }
      if (error) {
        return console.error("WiFiControl: " + msg);
      } else {
        if (this.WiFiControlSettings.debug) {
          return console.log("WiFiControl: " + msg);
        }
      }
    }
  };

  module.exports = {
    init: function(settings) {
      if (settings == null) {
        settings = {};
      }
      this.configure(settings);
      if (settings.iface == null) {
        return this.findInterface(settings.iface);
      }
    },
    configure: function(settings) {
      if (settings == null) {
        settings = {};
      }
      if (settings.debug != null) {
        private_context.WiFiControlSettings.debug = settings.debug;
        private_context.WiFiLog("Debug mode set to: " + settings.debug);
      }
      if (settings.iface != null) {
        return this.findInterface(settings.iface);
      }
    },
    findInterface: function(iface) {
      var _msg, error, error1, interfaceResults;
      if (iface == null) {
        iface = null;
      }
      try {
        if (iface != null) {
          _msg = "Wireless interface manually set to " + iface + ".";
          private_context.WiFiLog(_msg);
          private_context.WiFiControlSettings.iface = iface;
          return {
            success: true,
            msg: _msg,
            "interface": iface
          };
        }
        private_context.WiFiLog("Determining system wireless interface...");
        interfaceResults = os_instructions.autoFindInterface.call(private_context);
        private_context.WiFiControlSettings.iface = interfaceResults["interface"];
        return interfaceResults;
      } catch (error1) {
        error = error1;
        _msg = "Encountered an error while searching for wireless interface: " + error;
        private_context.WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    },
    scanForWiFi: function(cb) {
      var KEY, VALUE, _msg, _network, c, error, error1, error2, j, k, l, len, len1, ln, networks, nwk, parsedLine, ref, ref1, scanResults;
      if (WiFiControlSettings.iface == null) {
        _msg = "You cannot scan for nearby WiFi networks without a valid wireless interface.";
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
      try {
        WiFiLog("Scanning for nearby WiFi Access Points...");
        if (process.platform === "linux") {
          scanResults = execSync("nmcli -m multiline device wifi list");
          networks = [];
          ref = scanResults.split('*:');
          for (c = j = 0, len = ref.length; j < len; c = ++j) {
            nwk = ref[c];
            if (c === 0) {
              continue;
            }
            _network = {};
            ref1 = nwk.split('\n');
            for (k = l = 0, len1 = ref1.length; l < len1; k = ++l) {
              ln = ref1[k];
              try {
                parsedLine = parsePatterns.nmcli_line.exec(ln.trim());
                KEY = parsedLine[1];
                VALUE = parsedLine[2];
              } catch (error1) {
                error = error1;
                continue;
              }
              switch (KEY) {
                case "SSID":
                  _network.ssid = String(VALUE);
                  break;
                case "CHAN":
                  _network.channel = String(VALUE);
                  break;
                case "SIGNAL":
                  _network.signal_level = String(VALUE);
                  break;
                case "SECURITY":
                  _network.security = String(VALUE);
              }
            }
            if (_network.ssid !== "--") {
              networks.push(_network);
            }
          }
          _msg = "Nearby WiFi APs successfully scanned (" + networks.length + " found).";
          WiFiLog(_msg);
          return cb(null, {
            success: true,
            msg: _msg,
            networks: networks
          });
        } else {
          return WiFiScanner.scan(function(err, networks) {
            if (err) {
              _msg = "We encountered an error while scanning for WiFi APs: " + error;
              WiFiLog(_msg, true);
              return cb(err, {
                success: false,
                msg: _msg
              });
            } else {
              _msg = "Nearby WiFi APs successfully scanned (" + networks.length + " found).";
              WiFiLog(_msg);
              return cb(null, {
                success: true,
                networks: networks,
                msg: _msg
              });
            }
          });
        }
      } catch (error2) {
        error = error2;
        _msg = "We encountered an error while scanning for WiFi APs: " + error;
        WiFiLog(_msg, true);
        return cb(error, {
          success: false,
          msg: _msg
        });
      }
    },
    connectToAP: function(_ap) {
      var COMMANDS, _msg, com, connectToAPChain, error, error1, error2, error3, error4, i, ifaceState, j, l, len, ref, ssid, ssidExist, stdout, xmlContent;
      if (WiFiControlSettings.iface == null) {
        _msg = "You cannot connect to a WiFi network without a valid wireless interface.";
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
      try {
        if (!_ap.ssid.length) {
          return {
            success: false,
            msg: "Please provide a non-empty SSID."
          };
        }
        if (_ap.password == null) {
          _ap.password = "";
        }
        switch (process.platform) {
          case "linux":
            COMMANDS = {
              "delete": "nmcli connection delete \"" + _ap.ssid + "\"",
              connect: "nmcli device wifi connect \"" + _ap.ssid + "\""
            };
            if (_ap.password.length) {
              COMMANDS.connect += " password \"" + _ap.password + "\"";
            }
            try {
              stdout = execSync("nmcli connection show \"" + _ap.ssid + "\"");
              if (stdout.length) {
                ssidExist = true;
              }
            } catch (error1) {
              error = error1;
              ssidExist = false;
            }
            connectToAPChain = [];
            if (ssidExist) {
              WiFiLog("It appears there is already a connection for this SSID.");
              connectToAPChain.push("delete");
            }
            connectToAPChain.push("connect");
            break;
          case "win32":
            WiFiLog("Generating win32 wireless profile...");
            ssid = {
              plaintext: _ap.ssid,
              hex: ""
            };
            for (i = j = 0, ref = ssid.plaintext.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
              ssid.hex += ssid.plaintext.charCodeAt(i).toString(16);
            }
            xmlContent = null;
            if (_ap.password.length) {
              xmlContent = win32WirelessProfileBuilder(ssid, "wpa2", _ap.password);
            } else {
              xmlContent = win32WirelessProfileBuilder(ssid);
            }
            try {
              fs.writeFileSync(_ap.ssid + ".xml", xmlContent);
            } catch (error2) {
              error = error2;
              _msg = "Encountered an error connecting to AP: " + error;
              WiFiLog(_msg, true);
              return {
                success: false,
                msg: _msg
              };
            }
            COMMANDS = {
              loadProfile: "netsh " + WiFiControlSettings.iface + " add profile filename=\"" + _ap.ssid + ".xml\"",
              connect: "netsh " + WiFiControlSettings.iface + " connect ssid=\"" + _ap.ssid + "\" name=\"" + _ap.ssid + "\""
            };
            connectToAPChain = ["loadProfile", "connect"];
            break;
          case "darwin":
            COMMANDS = {
              connect: "networksetup -setairportnetwork " + WiFiControlSettings.iface + " \"" + _ap.ssid + "\""
            };
            if (_ap.password.length) {
              COMMANDS.connect += " \"" + _ap.password + "\"";
            }
            connectToAPChain = ["connect"];
        }
        for (l = 0, len = connectToAPChain.length; l < len; l++) {
          com = connectToAPChain[l];
          WiFiLog("Executing:\t" + COMMANDS[com]);
          try {
            stdout = execSync(COMMANDS[com]);
          } catch (error3) {
            error = error3;
            if (process.platform === "linux") {
              if (error.stderr.toString().trim() === ("Error: No network with SSID '" + _ap.ssid + "' found.")) {
                _msg = "Error: No network called " + _ap.ssid + " could be found.";
                WiFiLog(_msg, true);
                return {
                  success: false,
                  msg: _msg
                };
              } else if (error.stderr.toString().search(/Error:/ !== -1)) {
                _msg = error.stderr.toString().trim();
                WiFiLog(_msg, true);
                return {
                  success: false,
                  msg: _msg
                };
              }
              if (!/nmcli device wifi connect/.test(COMMANDS[com])) {
                WiFiLog(error, true);
                return {
                  success: false,
                  msg: error
                };
              }
            }
          }
          switch (process.platform) {
            case "darwin":
              if (stdout === ("Could not find network " + _ap.ssid + ".")) {
                _msg = "Error: No network called " + _ap.ssid + " could be found.";
                WiFiLog(_msg, true);
                return {
                  success: false,
                  msg: _msg
                };
              }
          }
          WiFiLog("Success!");
        }
        if (process.platform === "win32") {
          WiFiLog("Removing temporary WiFi config file...");
          execSync("del \".\\" + _ap.ssid + ".xml\"");
        }
        WiFiLog("Waiting for connection attempt to settle...");
        while (true) {
          ifaceState = this.getIfaceState();
          if (ifaceState.success) {
            if (ifaceState.connection === "connected") {
              break;
            } else if (ifaceState.connection === "disconnected") {
              _msg = "Error: Interface is not currently connected to any wireless AP.";
              WiFiLog(_msg, true);
              return {
                success: false,
                msg: _msg
              };
            }
          }
        }
        if (ifaceState.ssid === _ap.ssid) {
          _msg = "Successfully connected to " + _ap.ssid + "!";
          WiFiLog(_msg);
          return {
            success: true,
            msg: _msg
          };
        } else {
          _msg = "Error: Interface is currently connected to " + ifaceState.ssid;
          WiFiLog(_msg, true);
          return {
            success: false,
            msg: _msg
          };
        }
      } catch (error4) {
        error = error4;
        _msg = "Encountered an error while connecting to " + _ap.ssid + ": " + error;
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    },
    resetWiFi: function() {
      var COMMANDS, _msg, com, error, error1, ifaceState, j, len, resetWiFiChain, stdout;
      try {
        switch (process.platform) {
          case "linux":
            COMMANDS = {
              disableNetworking: "nmcli networking off",
              enableNetworking: "nmcli networking on"
            };
            resetWiFiChain = ["disableNetworking", "enableNetworking"];
            break;
          case "win32":
            COMMANDS = {
              disconnect: "netsh " + WiFiControlSettings.iface + " disconnect"
            };
            resetWiFiChain = ["disconnect"];
            break;
          case "darwin":
            COMMANDS = {
              enableAirport: "networksetup -setairportpower " + WiFiControlSettings.iface + " on",
              disableAirport: "networksetup -setairportpower " + WiFiControlSettings.iface + " off"
            };
            resetWiFiChain = ["disableAirport", "enableAirport"];
        }
        for (j = 0, len = resetWiFiChain.length; j < len; j++) {
          com = resetWiFiChain[j];
          WiFiLog("Executing:\t" + COMMANDS[com]);
          stdout = execSync(COMMANDS[com]);
          _msg = "Success!";
          WiFiLog(_msg);
        }
        WiFiLog("Waiting for interface to finish resetting...");
        while (true) {
          ifaceState = this.getIfaceState();
          if (ifaceState.success) {
            if (ifaceState.power) {
              WiFiLog("Success!  Wireless interface is now reset.");
              break;
            }
          } else {
            _msg = "Error: Interface could not be reset.";
            WiFiLog(_msg, true);
            return {
              success: false,
              msg: _msg
            };
          }
        }
        return {
          success: true,
          msg: "Successfully reset WiFi!"
        };
      } catch (error1) {
        error = error1;
        _msg = "Encountered an error while resetting wireless interface: " + error;
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    },
    getIfaceState: function() {
      var _msg, error, error1, interfaceState;
      try {
        interfaceState = os_instructions.getIfaceState.call(private_context);
        if (interfaceState.success !== false) {
          interfaceState.success = true;
          interfaceState.msg = "Successfully acquired state of network interface " + private_context.WiFiControlSettings.iface + ".";
        }
        return interfaceState;
      } catch (error1) {
        error = error1;
        _msg = "Encountered an error while acquiring network interface connection state: " + error;
        private_context.WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    }
  };

}).call(this);
